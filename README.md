## کتابخانه‌های مورد نیاز برای تلگرام

### 1. `requests`
- **نصب**: `pip install requests`
- **استفاده**: این کتابخانه برای ارسال درخواست‌های HTTP به سرویس وب و دریافت اطلاعات وضعیت لامپ‌ها استفاده می‌شود.

### 2. `python-telegram-bot`
- **نصب**: `pip install python-telegram-bot`
- **استفاده**: این کتابخانه برای ایجاد ربات تلگرام و ارتباط با API آن استفاده می‌شود. ابزارهای این کتابخانه شامل افزودن دستورات، پردازش پیام‌ها و پاسخ به کلیک‌های دکمه‌های شیشه‌ای هستند.

در اینجا از

### 3. `asyncio`
- **نصب**: این کتابخانه به صورت استاندارد در پایتون موجود است و نیاز به نصب اضافی ندارد.
- **استفاده**: برای مدیریت وظایف ناهمزمان و پردازش صف دستورات کاربر استفاده می‌شود.

### 4. `Flask`
- **نصب**:`pip install Flask`

- **استفاده**:  Flask به عنوان یک فریم‌ورک وب سروری، به شما امکانات زیر را فراهم می‌کند:
ساخت وب‌سایت‌های استاتیک و دینامیک
توسعه APIها و سرویس‌های وب
ایجاد بک‌اند برای وب اپلیکیشن‌های تحت وب
ارسال و دریافت درخواست‌های HTTP
ایجاد صفحات وب با قابلیت ارتباط با پایگاه‌های داده
پیاده‌سازی سیستم‌های مدیریت محتوا (CMS)
با استفاده از Flask، شما می‌توانید به راحتی برنامه‌های وب خود را توسعه دهید و سازماندهی کنید، از جمله برنامه‌هایی که با استفاده از آن طراحی می‌شوند از ساده‌ترین یک صفحه وب گرفته تا برنامه‌های وب پیچیده و پویا.






### توجهات:
- قبل از اجرای برنامه، اطمینان حاصل کنید که اطلاعات مربوط به ربات تلگرام (`BOT_TOKEN`)، آدرس سرویس Flask (`FLASK_APP_URL`) و کلید API (`API_KEY`) به درستی تنظیم شده باشند.
- برای استفاده از کتابخانه `python-telegram-bot`، از مدیریت‌گر محیطی مانند `pipenv` یا `virtualenv` استفاده کنید تا محیط توسعه مناسبی برای برنامه خود ایجاد کنید.

### کد تلگرام برای کنترل لامپ‌ها

### توابع اصلی

### `lamp_keyboard()`

این تابع یک صفحه کلید اینلاین برای نمایش وضعیت لامپ‌ها ایجاد می‌کند.

#### کتابخانه‌های مورد نیاز:
- `requests`: برای ارسال درخواست‌های HTTP به وب‌سرویس

#### استفاده:
- این تابع با استفاده از کلید API به وب‌سرویس ارسال درخواست می‌کند تا وضعیت هر یک از لامپ‌ها را دریافت کند و بر اساس آن، دکمه‌های مربوط به هر لامپ (روشن یا خاموش) را ایجاد می‌کند.

### `lamps_name(lamp_name)`

این تابع نام لامپ را به عنوان ورودی دریافت می‌کند و وضعیت فعلی آن را از وب‌سرویس دریافت می‌کند. سپس با توجه به وضعیت کنونی، لامپ را روشن یا خاموش می‌کند.

#### کتابخانه‌های مورد نیاز:
- `requests`: برای ارسال درخواست‌های HTTP به وب‌سرویس

#### استفاده:
- این تابع ابتدا با استفاده از کلید API وضعیت فعلی لامپ را از وب‌سرویس دریافت می‌کند. سپس بسته به وضعیت فعلی، دستور روشن یا خاموش کردن را به وب‌سرویس ارسال می‌کند و پیام مربوط به عملیات انجام شده را برمی‌گرداند.

### `process_queue()`

این تابع برای پردازش دستورات کاربران در صف استفاده می‌شود. اگر کاربر مورد نظر احراز هویت نشده باشد، پیام مناسب را برای او ارسال می‌کند.

#### کتابخانه‌های مورد نیاز:
- `asyncio`: برای مدیریت کارهای ناهمزمان

#### استفاده:
- این تابع به صورت مداوم از صف دستورات کاربران خوانده و در صورتی که کاربر احراز هویت شده باشد، دستورات را اجرا می‌کند و در غیر این صورت، پیامی به کاربر ارسال می‌کند که باید ابتدا احراز هویت کند.

## کتابخانه‌های مورد نیاز برای کل کد:
- `logging`: برای ثبت و نمایش پیام‌های لاگ
- `requests`: برای ارسال درخواست‌های HTTP به وب‌سرویس
- `telegram`, `telegram.ext`: برای ایجاد ربات تلگرام و اتصال به آن

## اتصال و اجرا

برنامه از اتصال به ربات تلگرام شما استفاده می‌کند تا دستورات را پردازش کند و به کاربران پاسخ دهد. برنامه با استفاده از کد زیر شروع و اجرا می‌شود:

```python
import asyncio
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes

# تابع اصلی
async def main():
    bot = ApplicationBuilder().token(BOT_TOKEN).build()

    bot.add_handler(CommandHandler('start', start_command_handler))
    bot.add_handler(CommandHandler('help', help_command_handler))
    bot.add_handler(CallbackQueryHandler(button_callback))
    bot.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, password_handler))
    bot.add_handler(CommandHandler('turn_on_lamp', turn_on_lamp_handler))
    bot.add_handler(CommandHandler('turn_off_lamp', turn_off_lamp_handler))
    bot.add_handler(MessageHandler(filters.ALL, message_handler))

    # Initialize the bot
    await bot.initialize()

    # Start processing the queue
    asyncio.create_task(process_queue())

    # Start the bot
    await bot.start()

    # Run the bot until it is stopped
    await bot.updater.start_polling()
    await asyncio.Event().wait()  # Instead of updater.idle()

# اجرای تابع اصلی
asyncio.run(main())
